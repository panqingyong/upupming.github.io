---
title: 编译原理总结
tags:
- compilers
---

## 自底向上的语法分析

### 术语

- 句型：栈 + 输入缓冲区剩余内容。
- 句柄：句型中的当前归约对象；一个句型中最左边的直接短语。
- 短语：一颗子树的所有叶子自左至右排列起来形成一个相对于子树根的的短语。
- 直接短语：仅有**父子两代**的一颗子树，它的所有叶子自左至右排列起来所形成的符号串。

### 移进——归约分析

#### 要素

- 栈：开始格局为 `#`，正常结束为 `#S`
- 输入缓冲区：开始格局为 `w#`，正常结束为 `#`
- 分析表 `M`
- 移进——归约控制程序

#### 四种动作

1. 移进：将下一符号移入栈
2. 归约：用产生式左侧的非终结符替换栈顶的句柄（某产生式右步）
3. 接受：分析成功
4. 出错：出错处理

#### 冲突

1. 移进归约冲突

    既可以移进又可以按照产生式进行归约。

2. 归约归约冲突

    可以按照多种产生式进行归约。

解决冲突的方法实际上就是对句柄的识别：

- 优先法：根据归约的先后次序为句型中相邻的文法符号规定优先关系

    - 句柄内相邻符号同时归约，定义为【同优先的】（$\equiv$）
    - 句柄两端符号的优先级要高于句柄外与之相邻的符号

    $$
    a_1 \cdots a_{i-1} \nless \textcolor{red}{a_i \equiv \cdots \equiv a_j} \ngtr a_{j+1} \cdots a_n
    $$

    定义了这种优先关系之后，语法分析程序就可以通过 $a_{i-1} \nless a_i$ 和 $a_j \ngtr a_{j+1}$ 这两个关系来确定句柄的头和尾了（上式的红色部分）。

- 状态法：句柄是逐步形成的，用状态来描述【不同时刻】下形成的句柄。因为句柄是产生式的右部，可用产生式来表示句柄的不同识别状态。

    例如 $S \to bBB$ 可分解为如下的识别状态：

    - $S \to .bBB$ 移进 b
    - $S \to b.BB$ 等待归约出 B
    - $S \to bB.B$ 等待归约出 B
    - $S \to bBB.$ 归约

### 算符优先分析法

在算数表达式中，各个算符的优先关系如下：

- $+ \nless *$
- $(\equiv)$
- $+ \ngtr +$

我们同样，可以将句型中的【终结符】当做『算符』，借助于算符之间的优先关系确定句柄。

#### 算符文法

如果文法 $G = (V, T, P, S)$ 中不存在形如

$$
A \to \alpha B C \beta
$$

的产生式，则称之为算符文法（OG——Operator Grammar）。

也就是说：如果文法 G 中不存在具有【相邻非终结符】的产生式，则称之为算符文法。

> 否则的话，B 和 C 的优先关系是无法确定的。

#### 优先关系

- 相邻：若 $S \to \cdots ab \cdots$ 或者 $S \to \cdots aQb \cdots$，则称 a,b 相邻。

只有相邻的终结符之间才会有关系。

> TODO: 优先关系的确定，根据文法 G。


### 习题

#### 1

设有如下文法 G，

$$
S \to a | ^ | (T) \\
T \to T,S|S
$$

1. 求其 FIRSTOP 和 LASTOP。
2. 计算其优先关系，并判断其是否为算符优先文法。

#### 2

设有如下文法 G：

$$
S \to A \\
A \to BA | \epsilon \\
B \to aB|b \\
$$

1. 试用识别活前缀的方式给出文法 G 的 LR(1) 项目集。
2. 构造 G 的 LR(1) 分析表。
3. 给出输入符号串 w = abab 的自底向上语法分析过程。

### 布尔表达式的代码生成

布尔表达式常用于流程控制语句，比如 `if`、`while` 和 `for` 语句，这种布尔表达式作用可由式子被计算之后程序所处的位置来表示。

跳转语句可以无需计算整个表达式的值而直接跳转，比如：

```c
if (p && (p->next)) { p = p->next;}
```

当 `p` 为 `false` 时，可以直接跳出语句块。

```txt
S->if E then S
S->if E then S else S
S->while E do S
```

属性：

- `E.true`: `E` 为 `true` 时，控制流的标签
- `E.false`: `E` 为 `false` 时，控制流的标签
- `*.code`: `*` 的 [3 地址码](https://www.geeksforgeeks.org/three-address-code-compiler/)
- `*.next`: 在 `*` 的 3 地址码之后的 3 地址码
- `*.place`: 存储指向 `E` 在符号表的值的指针
- `gen(...)`: 返回 3 地址码
- `||`： 被用于连接 3 地址码。
- `newtemp`: 返回新的临时变量
- `newlabel`: 返回新的标签

![20190402204832.png](https://i.loli.net/2019/04/02/5ca35a2c28554.png)

1. `E1` 为 `true` 时，控制流的标签为 `newlabel`
2. `E1` 为 `false` 时，控制流的标签等于 `E` 为 `false` 时控制流的标签
3. `E2` 为 `true` 时，控制流的标签等于 `E` 为 `true` 时控制流的标签
4. `E2` 为 `false` 时，控制流的标签等于 `E` 为 `false` 时控制流的标签
5. `E` 的 3 地址码代码等于先计算 `E1` 的 3 地址码，再计算 `E1.true` 的 3 地址码，最后计算 `E2` 的 3 地址码

#### 参考资料

1. [16IRGeneration.pdf](https://www.cse.iitk.ac.in/users/karkare/cs335/lectures/16IRGeneration.pdf)
2. [L11.pdf](https://webcourse.cs.technion.ac.il/236360/Winter2004-2005/ho/WCFiles/L11.pdf)
3. [lecture22.ppt](http://www.cs.fsu.edu/~xyuan/cot5300/lecture22.ppt)